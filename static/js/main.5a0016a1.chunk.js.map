{"version":3,"sources":["Structures/Vertex.js","Structures/Edge.js","Structures/Lightpath.js","Structures/helpFunc.js","Components/Circles.js","Components/Ring.js","Components/lines.js","Components/Line.js","Components/Home.js","Router.js","Components/Header.js","Loading.js","App.js","index.js"],"names":["Vertex","edge1","edge2","neighbor_vertex1","neighbor_vertex2","index","passing_lightpaths","this","Edge","neighbor_edge1","neighbor_edge2","vertex1","vertex2","Lightpath","wavelength","startVertex","endVertex","passing_edges","rand","min","max","Math","floor","random","randN","array","console","log","len","length","n","result","Array","taken","RangeError","x","sort","a","b","createLightpaths","optimalCirclesArr","vertexArr","edgeArr","lightpaths","i","circle","count","push","r","g","forEach","lightpath","v1","v2","vertex","start","target","current","edges_on_the_way","JSON","stringify","check_path","checkPathL","drawedje2","svg","cnt","radius","line","lineWidth","col","append","attr","PI","drawedje","drawcircles","arr","globalVertises","nodesWidth","className","d3","select","j","difference","cross","LPaths1","LPaths2","shuffle","require","drawVerteses","circles","LP","drawLP","LPindex","edge","checkCrossVerteses","f1","mainCircle","LParr","edgeCNT","circlesByLp","circlesByPassingEdges","appended","concat","countADMsOnline","countADMs","edgeCounter","Ring","loadState","event","setState","vertexCount","value","produceGraph","state","produceLightpathsOptimal","circlesArr","lightpathArr","lpOnlineCNT","optimalCirclesNum","unshift","appear","lpCNT","paths","document","querySelectorAll","showLpOnlineCNT","removeAttribute","simulate","showOffline","showOnline","reset","querySelector","innerHTML","type","placeholder","width","style","borderRadius","onBlur","to","onClick","toFixed","display","undefined","transform","Component","aadrawLPline","end","indexOfLevel","aadrawLPline2","optimalLines","levels","globalVerticies","svgclassName","svgHeight","lineLenght","lightPaths","indexInLp","drawVertesesForLines","level","appendLP","mainLine","levelsByPassingEdges","levelsByLP","levelIndex","partOfLP","drawLPS","Line","produceLightpaths","optimalLinesNum","levelsCNT","optimalLinesArr","vertexArrLine","pop","shift","createLightpathsLine","Home","alignSelf","Router","basename","path","component","exact","Loading","React","App","isLoading","setTimeout","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.5a0016a1.chunk.js","sourcesContent":["export default class Vertex {\r\n  constructor(edge1, edge2, neighbor_vertex1, neighbor_vertex2, index, passing_lightpaths) {\r\n    this.index = index;\r\n    this.neighbor_vertex1 = neighbor_vertex1;\r\n    this.neighbor_vertex2 = neighbor_vertex2;\r\n    this.edge1 = edge1;\r\n    this.edge2 = edge2;\r\n    this.passing_lightpaths = passing_lightpaths;\r\n  }\r\n\r\n}\r\n","export default class Edge {\r\n  constructor(neighbor_edge1, neighbor_edge2, vertex1, vertex2, index, passing_lightpaths) {\r\n    this.index = index;\r\n    this.neighbor_edge1 = neighbor_edge1;\r\n    this.neighbor_edge2 = neighbor_edge2;\r\n    this.vertex1 = vertex1;\r\n    this.vertex2 = vertex2;\r\n    this.passing_lightpaths = passing_lightpaths;\r\n  }\r\n}\r\n","export default class Lightpath {\r\n  constructor(wavelength, startVertex, endVertex, index, passing_edges) {\r\n    this.wavelength = wavelength;\r\n    this.passing_edges = passing_edges;\r\n    this.startVertex = startVertex;\r\n    this.endVertex = endVertex;\r\n    this.index = index;\r\n  }\r\n}","import Lightpath from \"./Lightpath\";\nimport Vertex from \"../Structures/Vertex\";\n\nconst rand = (min, max) => {\n  return Math.floor(Math.random() * (max - min)) + min;\n};\n\nconst randN = (array) => {\n  console.log(array, \"yoooooooooooooo\");\n  let len = array.length;\n\n  let n = Math.floor(Math.random() * len - 3) + 3;\n\n  let result = new Array(n);\n  let taken = new Array(n);\n  if (n > len) {\n    throw new RangeError(\"ERROR in length\");\n  }\n  while (n--) {\n    let x = Math.floor(Math.random() * len);\n    result[n] = array[x in taken ? taken[x] : x];\n    taken[x] = --len in taken ? taken[len] : len;\n  }\n  return result.length > 1\n    ? result.sort((a, b) => (a.index > b.index ? 1 : -1))\n    : randN(array);\n};\n\nconst createLightpaths = (optimalCirclesArr, vertexArr, edgeArr) => {\n  let lightpaths = [];\n  for (let i = 0; i < optimalCirclesArr.length; i++) {\n    const circle = optimalCirclesArr[i];\n    for (let count = 0; count < circle.length - 1; count++) {\n      lightpaths.push(\n        new Lightpath(\n          { r: rand(0, 255), g: rand(0, 255), b: rand(0, 255) },\n          circle[count].index,\n          circle[count + 1].index,\n          lightpaths.length\n        )\n      );\n    }\n    lightpaths.push(\n      new Lightpath(\n        { r: rand(0, 255), g: rand(0, 255), b: rand(0, 255) },\n        circle[circle.length - 1].index,\n        circle[0].index,\n        lightpaths.length\n      )\n    );\n  }\n  lightpaths.forEach((lightpath) => {\n    lightpath.passing_edges = check_path(\n      lightpath.startVertex,\n      lightpath.endVertex,\n      vertexArr,\n      edgeArr\n    );\n  });\n  return lightpaths;\n};\n\nconst createLightpathsLine = (optimalLinesArr, vertexArr) => {\n  let lightpaths = [];\n  for (let i = 0; i < optimalLinesArr.length; i++) {\n    const line = optimalLinesArr[i];\n    for (let count = 0; count < line.length - 1; count++) {\n      lightpaths.push(\n        new Lightpath(\n          { r: rand(0, 255), g: rand(0, 255), b: rand(0, 255) },\n          line[count].index,\n          line[count + 1].index,\n          lightpaths.length\n        )\n      );\n    }\n    // lightpaths.push(new Lightpath({ r: rand(0,255), g: rand(0,255), b: rand(0,255) }, line[circle.length - 1].index, line[0].index, lightpaths.length))\n  }\n  lightpaths.forEach((lightpath) => {\n    lightpath.passing_edges = checkPathL(\n      lightpath.startVertex,\n      lightpath.endVertex,\n      vertexArr\n    );\n  });\n  return lightpaths;\n};\n\nconst checkPathL = (v1, v2, vertex) => {\n  let start = new Vertex();\n  let target = new Vertex();\n  let current = new Vertex();\n  let edges_on_the_way = [];\n  start = { ...vertex[v1] };\n  target = { ...vertex[v2] };\n  current = { ...start };\n\n  while (!(JSON.stringify(target) === JSON.stringify(current))) {\n    edges_on_the_way.push(current.edge2);\n    current = { ...vertex[current.neighbor_vertex2] };\n  }\n  return edges_on_the_way;\n};\n\nfunction check_path(v1, v2, vertex) {\n  // console.log(vertex[v1], vertex[v2]);\n\n  let start = new Vertex();\n  let target = new Vertex();\n  let current = new Vertex();\n  let edges_on_the_way = [];\n\n  start = { ...vertex[v1] };\n  target = { ...vertex[v2] };\n  current = { ...start };\n\n  while (!(JSON.stringify(target) === JSON.stringify(current))) {\n    edges_on_the_way.push(current.edge2);\n    current = { ...vertex[current.neighbor_vertex2] };\n  }\n\n  console.log(edges_on_the_way);\n  return edges_on_the_way;\n\n  // let temp = edge;\n\n  // for (let i = 0; i < edges_on_the_way.length; i++) {\n\n  // }\n  // console.log(edges_on_the_way.filter(edge=> edge));\n  // return edges_on_the_way;\n}\n\nexport { randN, rand, createLightpaths, createLightpathsLine };\n","\nimport d3 from 'd3'\n\n\nfunction drawedje2(svg, start, cnt, radius, line, lineWidth, col = 'purple', index) {\n    svg.append('svg:path')\n        .attr('d', `M50 ${start} a ${radius} ${radius} 0 0 1 0 ${radius * 2} a ${radius} ${radius} 0 0 1 0 ${radius * (-2)}`)\n        .attr('fill', 'none')\n        .attr('stroke', col)\n        .attr('stroke-width', `${lineWidth}`)\n        .attr('stroke-dasharray', `0,${cnt},${line}, ${2 * radius * Math.PI - cnt - line < 0.00001 ? 0 : 2 * radius * Math.PI - cnt - line}`)\n        .attr('display', `none`)\n        .attr('class', `p${index}`)\n}\n\n\nfunction drawedje(svg, start, cnt, radius, line, lineWidth, col = 'purple') {\n    svg.append('svg:path')\n        .attr('d', `M50 ${start} a ${radius} ${radius} 0 0 1 0 ${radius * 2} a ${radius} ${radius} 0 0 1 0 ${radius * (-2)}`)\n        .attr('fill', 'none')\n        .attr('stroke', col)\n        .attr('stroke-width', `${lineWidth}`)\n        .attr('stroke-dasharray', `0,${cnt},${line}, ${2 * radius * Math.PI - cnt - line}`)\n}\n\n\nfunction drawcircles(arr, globalVertises, nodesWidth, className = '.svgpainter') {\n\n    let svg = d3.select(className)\n        .append('svg:svg')\n        .attr('viewBox', '0 0 90 90');\n    var length = arr.length\n\n    for (let j = 0; j < length; j++) {\n        let cnt = 0\n        let radius = 5 + (j * 3)\n        var line = ((2 * radius * Math.PI) - (globalVertises / 2)) / (globalVertises)\n        let start = 30 - (j * 3)\n\n        for (let i = 0; i < arr[j].length; i++) {\n            line = ((2 * radius * Math.PI) - (globalVertises / 2)) / (globalVertises)\n            let difference = arr[j][i].index\n            if (i > 0) {\n                difference = arr[j][i].index - arr[j][i - 1].index\n                line = (line * difference) + (difference / 2) - 0.5\n            } else {\n                if (difference === 0)\n                    line = 0\n                else\n                    line = (line * difference) + (difference / 2)\n            }\n            drawedje(svg, start, cnt, radius, line, 1)\n            cnt += line\n\n            drawedje(svg, start, cnt, radius, 0.5, nodesWidth)\n            cnt += 0.5\n        }\n        line = ((2 * radius * Math.PI) - (globalVertises / 2)) / (globalVertises)\n\n        drawedje(svg, start, cnt, radius, (2 * Math.PI * radius) - cnt, 1)\n\n\n    }\n    return svg\n}\n\n\nexport function getSVG(circlesArr, globalVertises) {\n    drawcircles(circlesArr, globalVertises, 3)\n}\n\n\nexport function cross(LPaths1,LPaths2){\n    for(var i=0;i<LPaths1.length;i++)\n        for(var j=0;j<LPaths2.length;j++)\n            if(LPaths1[i]===LPaths2[j]){\n                return true\n            }\n\n    return false\n}\n\n\nexport function shuffle(a) {\n    var j, x, i;\n    for (i = a.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\nexport function wait(ms) {\n    var start = Date.now(),\n        now = start;\n    while (now - start < ms) {\n        now = Date.now();\n    }\n\n}\n\nconst _ = require('lodash');\nexport function f(mainCircle, LParr, globalVertises) {\n    let circles = []\n    let svg = drawcircles(mainCircle, globalVertises, 3, '.svgpainter2')\n    console.log(LParr)\n    console.log('-------*****----------***--------------*****--------')\n    console.log(circles)\n\n    // get each light path one by one and put it in a circle\n    LParr.forEach(LP => {\n        let appended = false\n\n        console.log(_.cloneDeep(circles))\n        // for each circle check if there is room for current light path\n        circles.forEach((circle, index) => {\n            if (appended) {\n                return\n            }\n            let newCircle = false\n            circle.forEach(LPinCircle => {\n                if (newCircle)\n                    return\n                if (cross(LP.passing_edges, LPinCircle.passing_edges))\n                    newCircle = true\n            })\n\n            if (newCircle) {\n                return\n            }\n\n            circle.forEach(LPinCircle => {\n                if (appended) {\n                    return\n                }\n\n                if (cross([LPinCircle.startVertex, LPinCircle.endVertex], [LP.startVertex, LP.endVertex])) {\n                    // append the current light path to the current circle\n                    appended = true\n                    circles[index].push(LP)\n\n\n                    let start = 30 - ((index + 1) * 3)\n                    let radius = 5 + ((index + 1) * 3)\n                    let line = ((2 * radius * Math.PI)) / (globalVertises)\n                    LP.wavelength.r = LPinCircle.wavelength.r\n                    LP.wavelength.g = LPinCircle.wavelength.g\n                    LP.wavelength.b = LPinCircle.wavelength.b\n\n                    LP.passing_edges.forEach(edge => {\n                        //wait('2000')\n\n                        drawedje(svg, start, edge * line, radius, line, 3, `rgb(${LPinCircle.wavelength.r},${LPinCircle.wavelength.g},${LPinCircle.wavelength.b})`)\n                    })\n\n                    return\n                }\n            })\n\n        });\n\n        if (!appended) {\n            circles.push([LP])\n\n\n            let start = 30 - ((circles.length) * 3)\n            let radius = 5 + ((circles.length) * 3)\n            let line = ((2 * radius * Math.PI)) / (globalVertises)\n            LP.passing_edges.forEach(edge => {\n                //wait('2000')\n\n                drawedje(svg, start, edge * line, radius, line, 3, `rgb(${LP.wavelength.r},${LP.wavelength.g},${LP.wavelength.b})`)\n            })\n\n\n        }\n\n\n    });\n\n    console.log('------------------------------------')\n    //console.log(circles)\n    drawVerteses(circles, svg, globalVertises)\n\n}\n\n\n\nfunction drawVerteses(circles, svg, globalVertises) {\n    circles.forEach((circle, index) => {\n        circle.forEach(LP => {\n            let start = 30 - ((index + 1) * 3)\n            let radius = 5 + ((index + 1) * 3)\n            let line = ((2 * radius * Math.PI)) / (globalVertises)\n\n            drawedje2(svg, start, LP.startVertex * line, radius, 0.5, 3, 'red', `${LP.index}999`)\n            drawedje2(svg, start, LP.endVertex * line, radius, 0.5, 3, 'red', `${LP.index}999`)\n        })\n    });\n}\n\n\nfunction drawLP(LP, index, globalVertises, svg, LPindex) {\n    let start = 30 - ((index) * 3)\n    let radius = 5 + ((index) * 3)\n    let line = ((2 * radius * Math.PI)) / (globalVertises)\n\n    LP.passing_edges.forEach(edge => {\n        drawedje2(svg, start, edge * line, radius, line, 3, `rgb(${LP.wavelength.r},${LP.wavelength.g},${LP.wavelength.b})`, LPindex)\n    })\n}\n\nexport function checkCrossVerteses(LP,circle){\n    for(var i=0;i<circle.length;i++){\n        if(cross([circle[i].startVertex,circle[i].endVertex],[LP.startVertex,LP.endVertex])){\n            return true\n        }\n    }\n    return false\n}\n\nexport function f1(mainCircle,LParr,globalVertises,edgeCNT){\n    let circlesByLp=[]\n    let circlesByPassingEdges=[]\n    let svg=drawcircles(mainCircle,globalVertises,3,'.svgpainter3')\n    \n    LParr.forEach((LP,LPindex)=>{\n        LP.index=LPindex\n        let appended=false\n        circlesByPassingEdges.forEach((circle,index)=>{\n            if(appended){\n                return\n            }\n            if ((!cross(LP.passing_edges, circle)) && checkCrossVerteses(LP, circlesByLp[index])) {\n\n                circlesByPassingEdges[index] = circlesByPassingEdges[index].concat(LP.passing_edges)\n                circlesByLp[index].push(LP)\n\n                LP.wavelength.r = circlesByLp[index][0].wavelength.r\n                LP.wavelength.g = circlesByLp[index][0].wavelength.g\n                LP.wavelength.b = circlesByLp[index][0].wavelength.b\n                drawLP(LP, index + 1, globalVertises, svg, LPindex)\n\n                appended = true\n            }\n        })\n        if (!appended) {\n            circlesByPassingEdges.push(LP.passing_edges)\n            circlesByLp.push([LP])\n            drawLP(LP, circlesByLp.length, globalVertises, svg, LPindex)\n        }\n    })\n    drawVerteses(circlesByLp, svg, globalVertises)\n    return countADMsOnline(circlesByLp, edgeCNT)\n}\n\n\nconst countADMsOnline = (circlesByLp, edgeCNT) => {\n    let countADMs = 0;\n    console.log('i am herre');\n    console.log(circlesByLp);\n    circlesByLp.forEach(circle => {\n        let edgeCounter = 0\n        circle.forEach(lightpath => edgeCounter = lightpath.passing_edges.length + edgeCounter)\n        edgeCounter === edgeCNT ? countADMs = countADMs + circle.length : countADMs = countADMs + circle.length + 1\n    })\n    return countADMs;\n}\n","import React, { Component } from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport Vertex from \"../Structures/Vertex\";\r\nimport Edge from \"../Structures/Edge\";\r\n\r\nimport { rand, randN, createLightpaths } from \"../Structures/helpFunc.js\";\r\nimport { getSVG, f1, shuffle } from \"./Circles\";\r\n\r\nimport \"../App.css\";\r\n\r\nexport default class Ring extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      vertexCount: 0,\r\n      vertexArr: [],\r\n      edgeArr: [],\r\n      lightpathArr: [],\r\n      LParr: [],\r\n      lpCNT: 0,\r\n      showOffline: false,\r\n      showOnline: false,\r\n      lpOnlineCNT: 0,\r\n      showLpOnlineCNT: false,\r\n    };\r\n  }\r\n\r\n  loadState = (event) => {\r\n    this.setState({ vertexCount: event.target.value });\r\n  };\r\n\r\n  produceGraph = () => {\r\n    const { vertexCount, vertexArr, edgeArr } = this.state;\r\n\r\n    for (let i = 0; i < vertexCount; i++) {\r\n      switch (i) {\r\n        case 0:\r\n          vertexArr.push(\r\n            new Vertex(vertexCount - 1, i, vertexCount - 1, i + 1, i)\r\n          );\r\n          edgeArr.push(new Edge(vertexCount - 1, i, i, i + 1, i));\r\n          break;\r\n        case vertexCount - 1:\r\n          vertexArr.push(new Vertex(i - 1, vertexCount - 1, i - 1, 0, i));\r\n          edgeArr.push(new Edge(vertexCount - 1 - 1, 0, vertexCount - 1, 0, i));\r\n          break;\r\n        default:\r\n          vertexArr.push(new Vertex(i - 1, i, i - 1, i + 1, i));\r\n          edgeArr.push(new Edge(i - 1, i + 1, i, i + 1, i));\r\n          break;\r\n      }\r\n    }\r\n    console.log(vertexArr, edgeArr);\r\n  };\r\n\r\n  produceLightpathsOptimal = () => {\r\n    const {\r\n      vertexArr,\r\n      edgeArr,\r\n      lightpathArr,\r\n      LParr,\r\n      lpOnlineCNT,\r\n    } = this.state;\r\n    const optimalCirclesNum = rand(2, 7);\r\n\r\n    let optimalCirclesArr = new Array(optimalCirclesNum);\r\n\r\n    for (let i = 0; i < optimalCirclesNum; i++) {\r\n      optimalCirclesArr[i] = randN(vertexArr);\r\n    }\r\n\r\n    lightpathArr.push(...createLightpaths(optimalCirclesArr, vertexArr));\r\n    console.log(lightpathArr);\r\n\r\n    optimalCirclesArr.unshift(vertexArr);\r\n\r\n    getSVG(optimalCirclesArr, vertexArr.length);\r\n    LParr.push(...shuffle(lightpathArr));\r\n    console.log(LParr);\r\n    this.setState({\r\n      lpOnlineCNT:\r\n        lpOnlineCNT + f1([vertexArr], LParr, vertexArr.length, edgeArr.length),\r\n    });\r\n  };\r\n\r\n  appear = () => {\r\n    const { LParr, lpCNT } = this.state;\r\n    console.log(lpCNT);\r\n    let paths = document.querySelectorAll(`.p${lpCNT}`);\r\n    if (lpCNT >= LParr.length) {\r\n      this.setState({ showLpOnlineCNT: true });\r\n    } else {\r\n      for (var j = 0; j < LParr[lpCNT].passing_edges.length; j++) {\r\n        paths[j].removeAttribute(\"display\");\r\n      }\r\n    }\r\n    paths = document.querySelectorAll(`.p${lpCNT}999`);\r\n\r\n    if (lpCNT >= LParr.length) {\r\n      this.setState({ showLpOnlineCNT: true });\r\n    } else {\r\n      for (var i = 0; i < paths.length; i++) {\r\n        paths[i].removeAttribute(\"display\");\r\n      }\r\n    }\r\n    this.setState({ lpCNT: this.state.lpCNT + 1 });\r\n  };\r\n\r\n  simulate = () => {\r\n    this.setState({ showOffline: true, showOnline: true });\r\n    this.produceGraph();\r\n    this.produceLightpathsOptimal();\r\n  };\r\n\r\n  reset = () => {\r\n    \r\n    this.setState({\r\n      vertexArr : [],\r\nedgeArr : [],\r\nlightpathArr : [],\r\nLParr : [],\r\n      lpOnlineCNT: 0,\r\n      lpCNT: 0,\r\n      showOffline: false,\r\n      showOnline: false,\r\n      vertexCount: 0,\r\n      showLpOnlineCNT: false,\r\n    });\r\n    document.querySelector(\".svgpainter\").innerHTML = \"\";\r\n    document.querySelector(\".svgpainter3\").innerHTML = \"\";\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"container\">\r\n        <h1>How Many Nodes would you like to test the algorithm on? (Ring)</h1>\r\n        <div className=\"tc\">\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Number of Nodes\"\r\n            width=\"40%\"\r\n            style={{ borderRadius: \"10px\" }}\r\n            onBlur={this.loadState}\r\n            className=\"pa1 ma2 ba b--light-blue \"\r\n          />\r\n\r\n          <div>\r\n            <Link to=\"/\" className=\"generalButton\">\r\n              {\" \"}\r\n              Go Home{\" \"}\r\n            </Link>\r\n            <button className=\"generalButton\" onClick={this.simulate}>\r\n              Simulate\r\n            </button>\r\n            <button className=\"generalButton\" onClick={this.appear}>\r\n              Step Over\r\n            </button>\r\n            <button className=\"generalButton\" onClick={this.reset}>\r\n              Reset\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"tc\">\r\n          {this.state.showLpOnlineCNT ? (\r\n            <h3>\r\n              The C-Ratio in this Simulation is :{\" \"}\r\n              {(this.state.lpOnlineCNT / this.state.LParr.length).toFixed(2)}\r\n            </h3>\r\n          ) : null}\r\n        </div>\r\n        <div className=\"container2\">\r\n          <div\r\n            className=\"tc \"\r\n            style={{ display: this.state.showOffline ? null : \"none\" }}\r\n          >\r\n            <h3>\r\n              Optimal Solution <br /> Total ADMs: {this.state.LParr.length}\r\n            </h3>\r\n            <div className=\"tc svgpainter \"></div>\r\n          </div>\r\n\r\n          <div\r\n            className=\"tc \"\r\n            style={{ display: this.state.showOnline ? null : \"none\" }}\r\n          >\r\n            <h3>\r\n              OnLine minADM Solution <br />\r\n              Total ADMs:\r\n              {this.state.showLpOnlineCNT ? this.state.lpOnlineCNT : null}\r\n            </h3>\r\n            <h4>\r\n              {this.state.showOnline\r\n                ? this.state.LParr[this.state.lpCNT] !== undefined\r\n                  ? \"Next Lightpath start is : \" +\r\n                    this.state.LParr[this.state.lpCNT].startVertex\r\n                  : null\r\n                : null}{\" \"}\r\n              <br />{\" \"}\r\n              {this.state.showOnline\r\n                ? this.state.LParr[this.state.lpCNT] !== undefined\r\n                  ? \"end is : \" + this.state.LParr[this.state.lpCNT].endVertex\r\n                  : null\r\n                : null}\r\n            </h4>\r\n            <div\r\n              className=\"tc svgpainter3\"\r\n              style={{ transform: \"all 1s ease-in-out\" }}\r\n            ></div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import d3 from \"d3\";\nimport { cross, checkCrossVerteses } from \"./Circles\";\n\nfunction aadrawLPline(svg, start, end, indexOfLevel, lineWidth, col) {\n  svg\n    .append(\"svg:line\")\n    .attr(\"x1\", `${start}`)\n    .attr(\"y1\", `${indexOfLevel * 50 + 20}`)\n    .attr(\"x2\", `${end}`)\n    .attr(\"y2\", `${indexOfLevel * 50 + 20}`)\n    .attr(\"stroke\", col)\n    .attr(\"stroke-width\", `${lineWidth}`);\n}\n\nfunction aadrawLPline2(svg, start, end, indexOfLevel, lineWidth, col, LPindex) {\n  svg\n    .append(\"svg:line\")\n    .attr(\"x1\", `${start}`)\n    .attr(\"y1\", `${indexOfLevel * 50 + 20}`)\n    .attr(\"x2\", `${end}`)\n    .attr(\"y2\", `${indexOfLevel * 50 + 20}`)\n    .attr(\"stroke\", col)\n    .attr(\"stroke-width\", `${lineWidth}`)\n    .attr(\"display\", `none`)\n    .attr(\"class\", `p${LPindex}`);\n}\n\nexport function optimalLines(\n  levels,\n  globalVerticies,\n  svgclassName = \".svgpainter\",\n  svgHeight = false\n) {\n  if (svgHeight === false) {\n    svgHeight = levels.length * 70 + 20;\n  }\n\n  let svg = d3\n    .select(svgclassName)\n    .append(\"svg:svg\")\n    .attr(\"height\", `${svgHeight}`)\n    .attr(\"width\", \"250\");\n\n  let lineLenght = 250 / globalVerticies;\n\n  levels.forEach((lightPaths, indexOfLevel) => {\n    for (var i = 0; i < lightPaths.length - 1; i++) {\n      var indexInLp = lightPaths[i].index;\n      aadrawLPline(\n        svg,\n        indexInLp * lineLenght,\n        lightPaths[i + 1].index * lineLenght,\n        indexOfLevel,\n        10,\n        \"purple\"\n      );\n      aadrawLPline(\n        svg,\n        indexInLp * lineLenght,\n        indexInLp * lineLenght + 5,\n        indexOfLevel,\n        20,\n        \"purple\"\n      );\n      aadrawLPline(\n        svg,\n        lightPaths[i + 1].index * lineLenght,\n        lightPaths[i + 1].index * lineLenght + 5,\n        indexOfLevel,\n        20,\n        \"purple\"\n      );\n    }\n  });\n\n  return svg;\n}\n\nfunction drawVertesesForLines(levels, svg, globalVerticies) {\n  let lineLenght = 250 / globalVerticies;\n\n  levels.forEach((level, indexOfLevel) => {\n    level.forEach((LP, LPindex) => {\n      aadrawLPline2(\n        svg,\n        LP.passing_edges[0] * lineLenght,\n        LP.passing_edges[0] * lineLenght + 5,\n        indexOfLevel + 1,\n        20,\n        \"purple\",\n        `${LP.index}999`\n      );\n      aadrawLPline2(\n        svg,\n        (LP.passing_edges[LP.passing_edges.length - 1] + 1) * lineLenght,\n        (LP.passing_edges[LP.passing_edges.length - 1] + 1) * lineLenght + 5,\n        indexOfLevel + 1,\n        20,\n        \"purple\",\n        `${LP.index}999`\n      );\n    });\n    // let LP=level[level.length-1]\n    // let LPindex=level.length-1\n    // aadrawLPline2(svg,(LP.passing_edges[LP.passing_edges.length-1]+1)*lineLenght,((LP.passing_edges[LP.passing_edges.length-1]+1)*lineLenght)+5,+1,20,'purple',LPindex)\n  });\n}\n\nexport function onlineLines(mainLine, LParr, globalVerticies) {\n  let svg = optimalLines([mainLine], globalVerticies, \".svgpainter2\");\n  console.log(\"=================\");\n  console.log(LParr);\n\n  let lineLenght = 250 / globalVerticies;\n\n  let levelsByPassingEdges = [];\n  let levelsByLP = [];\n  LParr.forEach((LP, LPindex) => {\n    LP.index = LPindex;\n    let appended = false;\n    levelsByPassingEdges.forEach((level, index) => {\n      if (appended) {\n        return;\n      }\n      if (\n        !cross(level, LP.passing_edges) &&\n        checkCrossVerteses(LP, levelsByLP[index])\n      ) {\n        levelsByPassingEdges[index] = levelsByPassingEdges[index].concat(\n          LP.passing_edges\n        );\n        levelsByLP[index].push(LP);\n\n        LP.wavelength.r = levelsByLP[index][0].wavelength.r;\n        LP.wavelength.g = levelsByLP[index][0].wavelength.g;\n        LP.wavelength.b = levelsByLP[index][0].wavelength.b;\n\n        LP.passing_edges.forEach((partOfLP) => {\n          aadrawLPline2(\n            svg,\n            partOfLP * lineLenght,\n            (partOfLP + 1) * lineLenght,\n            index + 1,\n            10,\n            `rgb(${LP.wavelength.r},${LP.wavelength.g},${LP.wavelength.b})`,\n            LP.index\n          );\n        });\n\n        appended = true;\n      }\n    });\n\n    if (!appended) {\n      levelsByPassingEdges.push(LP.passing_edges);\n      levelsByLP.push([LP]);\n      LP.passing_edges.forEach((partOfLP) => {\n        aadrawLPline2(\n          svg,\n          partOfLP * lineLenght,\n          (partOfLP + 1) * lineLenght,\n          levelsByLP.length,\n          10,\n          `rgb(${LP.wavelength.r},${LP.wavelength.g},${LP.wavelength.b})`,\n          LP.index\n        );\n      });\n    }\n  });\n\n  drawVertesesForLines(levelsByLP, svg, globalVerticies);\n}\n\nexport function appendLP(mainLine, LParr, globalVerticies) {\n  let levelsByPassingEdges = [];\n  let levelsByLP = [];\n  LParr.forEach((LP, LPindex) => {\n    LP.index = LPindex;\n    let appended = false;\n    levelsByPassingEdges.forEach((level, index) => {\n      if (appended) {\n        return;\n      }\n\n      // check if we can append the current light path to the current level\n      if (\n        !cross(level, LP.passing_edges) &&\n        checkCrossVerteses(LP, levelsByLP[index])\n      ) {\n        // append the light path   ----------------------\n        levelsByPassingEdges[index] = levelsByPassingEdges[index].concat(\n          LP.passing_edges\n        );\n        levelsByLP[index].push(LP);\n        //------------------------------------------------\n\n        // making the light paths color as his level   -----------------\n        LP.wavelength.r = levelsByLP[index][0].wavelength.r;\n        LP.wavelength.g = levelsByLP[index][0].wavelength.g;\n        LP.wavelength.b = levelsByLP[index][0].wavelength.b;\n        //------------------------------------------------\n\n        appended = true;\n      }\n    });\n\n    if (!appended) {\n      levelsByPassingEdges.push(LP.passing_edges);\n      levelsByLP.push([LP]);\n    }\n  });\n\n  console.log(\"=================\");\n  console.log(LParr);\n\n  let svg = drawLPS(mainLine, levelsByLP, globalVerticies);\n  drawVertesesForLines(levelsByLP, svg, globalVerticies);\n  return levelsByLP.length;\n}\n\nfunction drawLPS(mainLine, levels, globalVerticies) {\n  console.log(\"=================\");\n  console.log(levels);\n  let svg = optimalLines(\n    [mainLine],\n    globalVerticies,\n    \".svgpainter2\",\n    levels.length * 50 + 70\n  );\n\n  let lineLenght = 250 / globalVerticies;\n\n  levels.forEach((level, levelIndex) => {\n    level.forEach((LP, LPindex) => {\n      LP.passing_edges.forEach((partOfLP) => {\n        aadrawLPline2(\n          svg,\n          partOfLP * lineLenght,\n          (partOfLP + 1) * lineLenght,\n          levelIndex + 1,\n          10,\n          `rgb(${LP.wavelength.r},${LP.wavelength.g},${LP.wavelength.b})`,\n          LP.index\n        );\n      });\n    });\n  });\n  return svg;\n}\n","import React, { Component } from \"react\";\r\nimport { Link } from \"react-router-dom\";\r\nimport Vertex from \"../Structures/Vertex\";\r\nimport Edge from \"../Structures/Edge\";\r\nimport {\r\n  rand,\r\n  randN,\r\n  createLightpathsLine,\r\n} from \"../Structures/helpFunc.js\";\r\nimport {  shuffle } from \"./Circles\";\r\nimport { optimalLines, appendLP } from \"./lines\";\r\n// import d3 from \"d3\";\r\nimport \"../App.css\";\r\n\r\nexport default class Line extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      vertexCount: 0,\r\n      vertexArr: [],\r\n      edgeArr: [],\r\n      lightpathArr: [],\r\n      LParr: [],\r\n      lpCNT: 0,\r\n      showOffline: false,\r\n      showOnline: false,\r\n      lpOnlineCNT: 0,\r\n      showLpOnlineCNT: false,\r\n      levelsCNT: 0,\r\n    };\r\n  }\r\n\r\n  produceGraph = () => {\r\n    const { vertexCount, vertexArr, edgeArr } = this.state;\r\n\r\n    for (let i = 0; i < vertexCount; i++) {\r\n      switch (i) {\r\n        case 0:\r\n          vertexArr.push(new Vertex(null, i, null, i + 1, i));\r\n          edgeArr.push(new Edge(null, i + 1, 0, i + 1, i));\r\n          break;\r\n        case vertexCount - 1:\r\n          vertexArr.push(new Vertex(i - 1, null, i - 1, null, i));\r\n          break;\r\n        default:\r\n          vertexArr.push(new Vertex(i - 1, i, i - 1, i + 1, i));\r\n          edgeArr.push(new Edge(i, i + 1, i - 1, i + 1, i));\r\n          break;\r\n      }\r\n    }\r\n    console.log(vertexArr, edgeArr);\r\n  };\r\n\r\n  loadState = (event) => {\r\n    this.setState({ vertexCount: event.target.value });\r\n  };\r\n\r\n  produceLightpaths = () => {\r\n    const {\r\n      vertexCount,\r\n      vertexArr,\r\n      \r\n      lightpathArr,\r\n      LParr,\r\n    } = this.state;\r\n    const optimalLinesNum = rand(2, 7);\r\n    this.setState({ levelsCNT: optimalLinesNum });\r\n\r\n    let optimalLinesArr = new Array(optimalLinesNum);\r\n    const vertexArrLine = [...vertexArr];\r\n    vertexArrLine.pop();\r\n    vertexArrLine.shift();\r\n\r\n    for (let i = 0; i < optimalLinesNum; i++) {\r\n      optimalLinesArr[i] = randN(vertexArrLine);\r\n      optimalLinesArr[i].unshift(vertexArr[0]);\r\n      optimalLinesArr[i].push(vertexArr[vertexCount - 1]);\r\n    }\r\n\r\n    lightpathArr.push(...createLightpathsLine(optimalLinesArr, vertexArr));\r\n\r\n    optimalLinesArr.unshift(vertexArr);\r\n\r\n    optimalLines(optimalLinesArr, vertexArr.length);\r\n\r\n    LParr.push(...shuffle(lightpathArr));\r\n\r\n    this.setState({\r\n      lpOnlineCNT:\r\n        this.state.lpOnlineCNT +\r\n        LParr.length +\r\n        appendLP(vertexArr, LParr, vertexArr.length),\r\n    });\r\n\r\n    // lightpathArr.push(...createLightpaths(optimalLinesArr, vertexArr))\r\n\r\n    // optimalLinesArr.unshift(vertexArr)\r\n    // getSVG(optimalLinesArr, vertexArr.length)\r\n\r\n    // LParr.push(...shuffle(lightpathArr))\r\n    // this.setState({ lpOnlineCNT: lpOnlineCNT + f1([vertexArr], LParr, vertexArr.length, edgeArr.length) })\r\n  };\r\n\r\n  appear = () => {\r\n    const { LParr, lpCNT } = this.state;\r\n    console.log(lpCNT);\r\n    let paths = document.querySelectorAll(`.p${lpCNT}`);\r\n    if (lpCNT >= LParr.length) {\r\n      this.setState({ showLpOnlineCNT: true });\r\n    } else {\r\n      for (var j = 0; j < LParr[lpCNT].passing_edges.length; j++) {\r\n        paths[j].removeAttribute(\"display\");\r\n      }\r\n    }\r\n    paths = document.querySelectorAll(`.p${lpCNT}999`);\r\n\r\n    if (lpCNT >= LParr.length) {\r\n      this.setState({ showLpOnlineCNT: true });\r\n    } else {\r\n      for (var i = 0; i < paths.length; i++) {\r\n        paths[i].removeAttribute(\"display\");\r\n      }\r\n    }\r\n    this.setState({ lpCNT: this.state.lpCNT + 1 });\r\n  };\r\n\r\n  simulate = () => {\r\n    this.setState({ showOffline: true, showOnline: true });\r\n    this.produceGraph();\r\n    this.produceLightpaths();\r\n  };\r\n\r\n  reset = () => {\r\n    \r\n    \r\n    \r\n    \r\n\r\n    this.setState({\r\n      vertexArr : [],\r\nedgeArr : [],\r\nlightpathArr : [],\r\nLParr : [],\r\n      lpOnlineCNT: 0,\r\n      lpCNT: 0,\r\n      showOffline: false,\r\n      showOnline: false,\r\n      vertexCount: 0,\r\n      showLpOnlineCNT: false,\r\n      levelsCNT: 0,\r\n    });\r\n    document.querySelector(\".svgpainter\").innerHTML = \"\";\r\n    document.querySelector(\".svgpainter2\").innerHTML = \"\";\r\n  };\r\n\r\n  render() {\r\n    return (\r\n      <div className=\"container\">\r\n        <h1>How Many Nodes would you like to test the algorithm on? (Line)</h1>\r\n        <div className=\"tc\">\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Number of Nodes\"\r\n            width=\"40%\"\r\n            style={{ borderRadius: \"10px\" }}\r\n            onBlur={this.loadState}\r\n            className=\"pa1 ma2 ba b--light-blue \"\r\n          />\r\n\r\n          <div>\r\n            <Link to=\"/\" className=\"generalButton\">\r\n              {\" \"}\r\n              Go Home{\" \"}\r\n            </Link>\r\n            <button className=\"generalButton\" onClick={this.simulate}>\r\n              Simulate\r\n            </button>\r\n            <button className=\"generalButton\" onClick={this.appear}>\r\n              Step Over\r\n            </button>\r\n            <button className=\"generalButton\" onClick={this.reset}>\r\n              Reset\r\n            </button>\r\n          </div>\r\n        </div>\r\n        <div className=\"tc\">\r\n          {this.state.showLpOnlineCNT ? (\r\n            <h3>\r\n              The C-Ratio in this Simulation is :{\" \"}\r\n              {(\r\n                this.state.lpOnlineCNT /\r\n                (this.state.LParr.length + this.state.levelsCNT)\r\n              ).toFixed(2)}\r\n            </h3>\r\n          ) : null}\r\n        </div>\r\n        <div className=\"container2\">\r\n          <div\r\n            className=\" tc\"\r\n            style={{ display: this.state.showOffline ? null : \"none\" }}\r\n          >\r\n            <h3>\r\n              Optimal Solution <br /> Total ADMs:{\" \"}\r\n              {this.state.LParr.length + this.state.levelsCNT}\r\n            </h3>\r\n            <div className=\"tc svgpainter container\"></div>\r\n          </div>\r\n\r\n          <div\r\n            className=\"tc \"\r\n            style={{ display: this.state.showOnline ? null : \"none\" }}\r\n          >\r\n            <h3>\r\n              OnLine minADM Solution <br />\r\n              Total ADMs:\r\n              {this.state.showLpOnlineCNT ? this.state.lpOnlineCNT : null}\r\n            </h3>\r\n            <h4>\r\n              {this.state.showOnline\r\n                ? this.state.LParr[this.state.lpCNT] !== undefined\r\n                  ? \"Next Lightpath start is : \" +\r\n                    this.state.LParr[this.state.lpCNT].startVertex\r\n                  : null\r\n                : null}{\" \"}\r\n              <br />{\" \"}\r\n              {this.state.showOnline\r\n                ? this.state.LParr[this.state.lpCNT] !== undefined\r\n                  ? \"end is : \" + this.state.LParr[this.state.lpCNT].endVertex\r\n                  : null\r\n                : null}\r\n            </h4>\r\n            <div\r\n              className=\"tc svgpainter2 container\"\r\n              style={{\r\n                transform: \"all 1s ease-in-out\",\r\n              }}\r\n            ></div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from 'react'\r\nimport { Link } from \"react-router-dom\";\r\nexport default class Home extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"container\">\r\n        <h1>\r\n          Today we are going to present to you the span MinADM Algorithm and\r\n          simulate it!\r\n        </h1>\r\n        <h3>Buckle Up!</h3>\r\n        <p>\r\n          We are going to present infront of you simulations on two\r\n          topologies, Ring and Line Topology.\r\n        </p>\r\n        <div>\r\n          <Link to=\"/\" className=\"generalButton\"> More Info</Link>\r\n\r\n          <Link to=\"/Ring\" className=\"generalButton\"> Ring Topology</Link>\r\n\r\n          <Link to=\"/Line\" className=\"generalButton\"> Line Topology</Link>\r\n        </div>\r\n        <h4 style={{ alignSelf: \"center\" }}>\r\n          This Project is Brought to you by Amir & Fida\r\n        </h4>\r\n        <h4>Supervised By Prof. Shmuel</h4>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport { HashRouter, Route, Switch } from \"react-router-dom\";\r\nimport Ring from \"./Components/Ring\";\r\nimport Line from \"./Components/Line\";\r\nimport Home from \"./Components/Home\";\r\nimport Header from \"./Components/Header\";\r\n\r\nconst Router = () => (\r\n  <HashRouter basename='/'>\r\n    <div>\r\n      {/* <Header /> */}\r\n      <Switch>\r\n        <Route path=\"/\" component={Home} exact={true} />\r\n        <Route path=\"/Ring\" component={Ring} />\r\n        <Route path=\"/Line\" component={Line} />\r\n        {/* <Route path=\"/add-role\" component={AddRole} /> */}\r\n      </Switch>\r\n\r\n    </div>\r\n  </HashRouter>\r\n);\r\n\r\nexport default Router;","import React, { Component } from 'react'\r\n\r\nexport default class Header extends Component {\r\n  render() {\r\n    return (\r\n      <div className=\"container\">\r\n        <h1>\r\n          Today we are going to present to you the span MinADM Algorithm and\r\n          simulate it!\r\n        </h1>\r\n        <h3>Buckle Up!</h3>\r\n        <p>\r\n          We are going to present infront of you simulations on two\r\n          topologies, Ring and Line Topology.\r\n        </p>\r\n      </div>\r\n    )\r\n  }\r\n}\r\n","import React from \"react\";\n\n\nexport default class Loading extends React.Component {\n  render() {\n    return (\n        <div className=\"row justify-content-center\">\n          <div className=\"col ml-3 mt-3\">\n\n          </div>\n        </div>\n    );\n  }\n}\n","import React from \"react\";\r\nimport Router from \"./Router\";\r\nimport Loading from \"./Loading\";\r\nclass App extends React.Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      isLoading: true\r\n    };\r\n  }\r\n  componentDidMount() {\r\n    setTimeout(() => {\r\n      this.setState({\r\n        isLoading: false\r\n      });\r\n    }, 3000);\r\n  }\r\n\r\n  render() {\r\n    return this.state.isLoading ? <Loading /> : <Router />;\r\n  }\r\n}\r\nexport default App;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"./App.css\";\nimport App from \"./App\";\nimport 'tachyons';\nReactDOM.render(<div className=\"container\">\n  <App />\n</div>\n  , document.getElementById(\"root\"));\n"],"sourceRoot":""}